

Plan of action:
-make script to test speed and append to a file, at the same time need to check for correctness
-parallelise simple functions with omp. investigate difference between collapse and non collapse
-run strong scaling tests
-parallelise harder functions, check for correctness
-perform strong scaling on hamilton up to 128 processes
-do this for maybe 2 problem sizes and investigate if any difference
-use python to create strong scaling plot 
-create report detailing the parallelisation strategy, maths for speedup, results  


Development Notes:
-Made initial speed and correctness tests, ran the serial speed test on hamilton and recorded the inital benchmark.
-Made script for strong scaling tests, made a makefile to clean up all files from these tests. 
-Added initial parallel clauses to Init, step and norm. I will run the speed tests on these.
-the source at this point saved as "part1_first_attempt.c" with the speed test saved as simple_omp_speed.dat
-now i will attempt to collapse these into a single list and for loop
-starting with init i notice it may be slower, so i will run a test with just the changes to init to see
-after logging back into hamilton i noticed it may be significantly slower for the simple omp additions, 
-thus i will break the implementations down into their own source to test individually, using default, manual and collapse
-Now i will change the slurm script to run 5 of each simulation and record all the speeds. to help me find an mean


 

Init:
-Given that u and v are linear lists, it might be worth finding the max value of index and doing only 1 iteration over that. 
-this is similar to doing a collapse but with potentially less overhad, this is worth testing for
-for now, just implement with the basic for. 
-On attempting to manually collapse I noticed each iteration requires a division, I have a hunch this will be expensive so i will run a test now 

Step
-Unlike init, step does not use i and j in the loop. Therefore calculating  idx using i and j is just extra work. 
-I suspect that by collapsing the for loop this will get gains, i will test for basic implementation, collapsed and manual collapsed



Norm:
-Easily parallelised using a for reduction clause, but again like step and init it could be potentially be improved by making a 1d array
 
